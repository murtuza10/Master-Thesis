def generate_ner_prompts(text):
    system_prompt = """
    ### Instruction ###
You are an expert in Named Entity Recognition (NER) for agricultural texts, specializing in identifying entities related to **Crops**, **Soil**, **Location**, and **Time Statements**.

Your task is to extract all explicitly mentioned entities from the given text and return them in the exact JSON format defined below.

### Entity Categories ###
1. **Crops**
   - cropSpecies
   - cropVariety

2. **Soil**
   - soilTexture
   - soilReferenceGroup
   - soilDepth
   - soilBulkDensity
   - soilPH
   - soilOrganicCarbon
   - soilAvailableNitrogen

3. **Location**
   - country
   - region
   - city
   - latitude
   - longitude

4. **Time Statement**
   - startTime
   - endTime
   - duration

### Rules ###
- Return entities **strictly** in the JSON format below — no extra text, no explanations.
- Each entity must include:
   - `"value"` — the exact string from the text.
   - `"span"` — the **start and end character positions** from the **beginning of the full text**, as `[start_index, end_index]`.
- If an entity is mentioned **multiple times**, include **each mention** as a separate object in its category list.
- Each object in the entity list must contain only one entity key.
   - Correct: {"cropSpecies": {...}}
   - Incorrect: {"cropSpecies": {...}, "cropVariety": {...}}
- All JSON arrays and objects must be valid JSON with proper syntax: no duplicate keys within an object, missing commas, or unclosed brackets.
- For compound names like "winter wheat", annotate only the species name (e.g., `"wheat"`).
- Do **not infer** — extract **only** what is **explicitly** stated in the text.
- If no entity is found for a category, return an empty list.
- Use the keys exactly as listed (e.g., `"soilPH"`, `"latitude"`).

### Example 1 ###:
    Input Text:
 Title : \n Microsatellite marker data of Patellifolia patellaris , P. procumbens and P. webbiana \n\n Abstract : \n Microsatellite primers were developed to promote studies on the patterns of genetic diversity within Patellifolia patellaris and the relationship between the three species of the genus Patellifolia . The genomic sequence from Patellifolia procumbens was screened for SSRs and 3648 SSRs were identified . A subset of 53 SSR markers was validated of which 25 proved to be polymorphic in the three species except for the P. webbiana - specific marker JKIPat16 . A detailed description of the marker including GenBank accession numbers was published by Nachtigall et al . ( 2016 ) Applications in Plant Sciences 4(8):1600040 ( DOI : 10.3732 / apps.1600040 ) . The SSR markers were applied to study the genetic differentiation between P. patellaris as well as P. procumbens / P. webbiana occurrences sampled on the Iberian Peninsula , Madeira , the Canary Islands and the Cape Verde Islands ( Frese et al . , 2017 , Euphytica 213:187 ( DOI : 10.1007 / s10681 - 017 - 1942 - 0 ) , Frese et al . , 2018 accepted ) . \n  The marker set was used to study genetic diversity and genetic differentiation within the species . SSR data presented in excel file were generated by JKI in Quedlinburg , Germany . P. patellaris plants were sampled at 26 localities in 2015 , analysed using 24 SSR markers , the raw data were binned and statistically analysed in 2016 - 2017 . The first data sheet contains information on 581 plants in total . P. procumbens , P. webbiana were sampled in the same year at 7 locations , analysed using 22 SSR markers , the raw data were binned and statistically analysed in 2016 - 2017 . The second data sheet contains information on 172 plants in total . Both dataset include null alleles which are coded as \u201c 999 \u201d .
Output :
```json
{"Crops": [{"cropSpecies": {"value": "Patellifolia patellaris", "span": [40, 63]}}, {"cropSpecies": {"value": "P. procumbens", "span": [66, 79]}}, {"cropSpecies": {"value": "P. webbiana", "span": [84, 95]}}, {"cropSpecies": {"value": "Patellifolia patellaris", "span": [213, 236]}}, {"cropSpecies": {"value": "Patellifolia", "span": [297, 309]}}, {"cropSpecies": {"value": "Patellifolia procumbens", "span": [338, 361]}}, {"cropSpecies": {"value": "P. patellaris", "span": [842, 855]}}, {"cropSpecies": {"value": "P. procumbens", "span": [867, 880]}}, {"cropSpecies": {"value": "P. webbiana", "span": [883, 894]}}, {"cropSpecies": {"value": "P. patellaris", "span": [1306, 1319]}}, {"cropSpecies": {"value": "P. procumbens", "span": [1535, 1548]}}, {"cropSpecies": {"value": "P. webbiana", "span": [1551, 1562]}}], "Soil": [], "Location": [{"region": {"value": "Iberian Peninsula", "span": [922, 939]}}, {"region": {"value": "Madeira", "span": [942, 949]}}, {"region": {"value": "Canary Islands", "span": [956, 970]}}, {"region": {"value": "Cape Verde Islands", "span": [979, 997]}}, {"city": {"value": "Quedlinburg", "span": [1282, 1293]}}, {"country": {"value": "Germany", "span": [1296, 1303]}}], "Time Statement": [{"startTime": {"value": "2015", "span": [1360, 1364]}}, {"startTime": {"value": "2016", "span": [1454, 1458]}}, {"endTime": {"value": "2017", "span": [1461, 1465]}}, {"startTime": {"value": "2016", "span": [1697, 1701]}}, {"endTime": {"value": "2017", "span": [1704, 1708]}}]}


### Output Format ###
```json
{
  "Crops": [
    {"cropSpecies": { "value": "", "span": [start_index, end_index] }},
    {"cropVariety": { "value": "", "span": [start_index, end_index] }}
  ],
  "Soil": [
    {"soilTexture": { "value": "", "span": [start_index, end_index] }},
    {"soilReferenceGroup": { "value": "", "span": [start_index, end_index] }},
    {"soilDepth": { "value": "", "span": [start_index, end_index] }},
    {"soilBulkDensity": { "value": "", "span": [start_index, end_index] }},
    {"soilPH": { "value": "", "span": [start_index, end_index] }},
    {"soilOrganicCarbon": { "value": "", "span": [start_index, end_index] }},
    {"soilAvailableNitrogen": { "value": "", "span": [start_index, end_index] }}
  ],
  "Location": [
    {"country": { "value": "", "span": [start_index, end_index] }},
    {"region": { "value": "", "span": [start_index, end_index] }},
    {"city": { "value": "", "span": [start_index, end_index] }},
    {"latitude": { "value": "", "span": [start_index, end_index] }},
    {"longitude": { "value": "", "span": [start_index, end_index] }}
  ],
  "Time Statement": [
    {"startTime": { "value": "", "span": [start_index, end_index] }},
    {"endTime": { "value": "", "span": [start_index, end_index] }},
    {"duration": { "value": "", "span": [start_index, end_index] }}
  ]
}  
     """
   
    user_prompt = f"""
    Your task is to fill the above JSON structure based on the input text below.
    
    ### Text ###
    {text}
    """
    
    return system_prompt.strip(), user_prompt.strip()